import{W as P,B as O,a as I,H as M,I as $,P as B,S as C,b as K,T as L,c as S,M as q,G as U,d as H,C as R,p as W}from"./gameManager-DgmvpVLR.js";class T extends P{constructor(t,s,o,i,n,r,a=.01){super(t,s,o,i),this.sx=t,this.sy=s,this.dw=n,this.dh=r,this.t=0,this.speed=a}draw(){super.draw(),this.t+=this.speed,this.x=this.sx+this.dw*cos(this.t),this.y=this.sy+this.dh*sin(this.t),push(),noFill(),strokeWeight(1),stroke(255,0,0),rect(this.sx+this.w/2-this.dw,this.sy+this.h/2-this.dh,2*this.dw,2*this.dh),pop()}}class l{constructor(t,s,o){this.pos=createVector(t,s),this.r=4,this.selected=!1,this.prevPos=createVector(t,s),this.parent=o}draw(){this.update(),push(),this.selected||this.pos.dist(mousePos)<this.r*2?(strokeWeight(1),stroke(0),fill(0,138,124)):fill(0,186,168),circle(this.pos.x,this.pos.y,this.r*2),pop()}update(){this.prevPos=this.pos.copy(),this.selected&&(this.pos=mousePos,this.parent.update(this,p5.Vector.sub(this.pos,this.prevPos)))}check(){return!mouseIsPressed&&this.selected&&(this.selected=!1),mouseIsPressed&&mouseButton!=CENTER&&!this.selected&&this.pos.dist(mousePos)<this.r*2&&(this.selected=!0),this.selected}toString(){return`${Math.round(this.pos.x)}, ${Math.round(this.pos.y)}`}}const x={[O]:"Ball",[I]:"Bouncer",[M]:"Hole",[$]:"Ice",[B]:"PolygonWall",[C]:"Sand",[K]:"Slope",[L]:"Teleporter",[P]:"Wall",[S]:"Water",[T]:"MovingPlatform"};class v{constructor(t,s=!0){this.obj=t,this.knot=new l(t.pos.x,t.pos.y,this),s&&main.staticKnots.push(this.knot)}draw(){this.obj.draw(),this.knot.draw()}update(){this.obj.pos=this.knot.pos.copy()}export(){return`new ${x[this.obj.constructor]}(${this.knot})`}}class w extends l{constructor(t,s,o){super(d(t),d(s),o)}update(){this.prevPos=this.pos.copy(),this.selected&&(this.pos=createVector(d(mousePos.x),d(mousePos.y)),this.parent.update(this,p5.Vector.sub(this.pos,this.prevPos)))}}function d(e){return round(e/50)*50}class D{constructor(){this.pos=createVector(width/2,height/2),this.scale=1}draw(){translate(width/2,height/2),scale(this.scale),translate(-this.pos.x,-this.pos.y),this.offset?window.mousePos=p5.Vector.sub(this.offset,createVector(mouseX,mouseY)).div(this.scale):window.mousePos=createVector(mouseX,mouseY).sub(createVector(width/2,height/2)).div(this.scale).add(this.pos),this.offset&&(this.pos=mousePos.add(this.initialPos))}drawGrid(){push(),strokeWeight(1);for(let t=d(this.pos.x-width/2/this.scale);t<=d(this.pos.x+width/2/this.scale);t+=25)stroke(255,t%50==0?125:50),line(t,this.pos.y-height/2/this.scale,t,this.pos.y+height/2/this.scale);for(let t=d(this.pos.y-height/2/this.scale);t<=d(this.pos.y+height/2/this.scale);t+=25)stroke(255,t%50==0?125:50),line(this.pos.x-width/2/this.scale,t,this.pos.x+width/2/this.scale,t);pop()}beginMove(){this.initialPos=this.pos.copy(),this.offset=createVector(mouseX,mouseY)}endMove(){this.initialPos=null,this.offset=null}changeScale(t){t>0?this.scale*=.9:this.scale*=1.1}}class G{constructor(){this.knots=[new w(0,0,this),new w(width,0,this),new w(width,height,this),new w(0,height,this)],main.staticKnots.push(...this.knots)}draw(){push(),fill(94,230,83),strokeWeight(3),stroke(255),beginShape();for(const t of this.knots)vertex(t.pos.x,t.pos.y);endShape(CLOSE),pop();for(const t of this.knots)t.draw()}update(){}convertKnots(){return this.knots.map(t=>[t.pos.x,t.pos.y])}addPoint(t,s){const o=new w(t,s,this),i=this.knots;if(i.length<2)i.push(o);else{let n=1/0,r=0;const a=o.pos;for(let h=0;h<i.length;h++){const c=i[h].pos,p=i[(h+1)%i.length].pos,k=p5.Vector.sub(a,c),u=p5.Vector.sub(p,c),m=u.setMag(k.dot(u)/u.mag()).add(c),b=m.dist(a);m.dist(c)+m.dist(p)>=c.dist(p)+5||b<n&&(r=h+1,n=b)}i.splice(r,0,o)}main.staticKnots.push(o),this.update()}export(){return JSON.stringify(this.convertKnots())}}class N{constructor(){this.balls=[],this.staticObjs=[],this.hasSelected=!1,this.staticKnots=[]}init(){this.mainb=new v(new q(80,80),!1),this.hole=new v(new M(width-80,height-80),!1),this.balls.push(this.mainb),this.levelBounds=new G,this.camera=new D}playMode(){const t=new f(this);window.main=t,t.init(),t.generateLevel()}draw(){this.camera.draw(),background(123,255,123),this.levelBounds.draw(),this.camera.drawGrid();for(const t of this.staticObjs)t.draw();this.hole.draw();for(const t of this.balls)t.draw();this.hasSelected||this.checkKnots()}checkKnots(){if(!this.selectedPolygon){for(let t=this.balls.length-1;t>=0;t--)if(this.balls[t].knot.check()){this.hasSelected=!0;return}if(this.hole.knot.check()){this.hasSelected=!0;return}for(let t=this.staticKnots.length-1;t>=0;t--)if(this.staticKnots[t].check()){this.hasSelected=!0;return}}}}class f extends U{constructor(t){super(),this.editor=t}init(){this.transition=new H(this.reset.bind(this))}reset(){window.main=this.editor;const t=this.editor.mainb.obj;t.vel.setMag(0),t.inHole=!0,this.editor.mainb.update()}generateLevel(){this.mainb=this.editor.mainb.obj,this.mainb.inHole=!1,this.balls.push(this.mainb),this.hole=this.editor.hole.obj,this.hole.ballIn=!1;for(const r of this.editor.staticObjs)this.staticObjs.push(r.obj);const t=this.editor.levelBounds.convertKnots();this.levelBounds=t;let s=t[0][0],o=t[0][1],i=t[0][0],n=t[0][1];for(let r=1;r<t.length;r++){let[a,h]=t[r];a<s&&(s=a),h<o&&(o=h),a>i&&(i=a),h>n&&(n=h)}this.camera=new R(s,o,i,n)}}function V(e,t){const s=document.createElement("div"),o=document.createElement("input");o.value=t;const i=document.createElement("button");return i.innerHTML="&times;",i.addEventListener("click",()=>{for(let n=0;n<main.staticObjs.length;n++){const r=main.staticObjs[n];if(e==r){main.staticObjs.splice(n,1);break}}s.remove()}),s.append(o,i),s}function Y(e,t){const s=V(e,t),o=document.createElement("button");return o.textContent="rotate",o.addEventListener("click",()=>{e.obj.force.rotate(PI/2)}),s.append(o),s}function g(e,t){const s=V(e,t),o=document.createElement("button");return o.textContent="edit",o.addEventListener("click",()=>{window.main.selectedPolygon=e}),s.append(o),s}class E extends l{constructor(t,s,o,i){super(t,s,o),this.origin=createVector(t,s),this.axis=i}originUpdate(t){this.pos.add(t)}update(){if(this.prevPos=this.pos.copy(),this.selected){const t=mousePos,s=p5.Vector.sub(t,this.origin),o=p5.Vector.setMag(this.axis,s.dot(this.axis)/this.axis.mag()).add(this.origin);this.pos=o,this.parent.update(this,p5.Vector.sub(this.pos,this.prevPos))}}}class y{constructor(t){this.obj=t,this.knots=[],this.centerKnot=new l(0,0,this),main.staticKnots.push(this.centerKnot)}draw(){this.obj.draw();for(const t of this.knots)t.draw();this.centerKnot.draw()}convertKnots(){return this.knots.map(t=>[t.pos.x,t.pos.y])}update(t,s){if(t==this.centerKnot)for(const o of this.knots)o.pos.add(s);else this.calcCenter();if(this.obj instanceof S){const o=this.centerKnot.pos.x,i=this.centerKnot.pos.y;this.obj.cx=o,this.obj.cy=i;const n=[];for(const r of this.knots)n.push([r.pos.x-o,r.pos.y-i]);this.obj.render=n}this.obj.points=this.convertKnots()}calcCenter(){let t=0,s=0;for(const o of this.knots)t+=o.pos.x,s+=o.pos.y;t/=this.knots.length,s/=this.knots.length,this.centerKnot.pos=createVector(t,s)}addPoint(t,s){const o=new l(t,s,this),i=this.knots;if(i.length<2)i.push(o);else{let n=1/0,r=0;const a=o.pos;for(let h=0;h<i.length;h++){const c=i[h].pos,p=i[(h+1)%i.length].pos,k=p5.Vector.sub(a,c),u=p5.Vector.sub(p,c),m=u.setMag(k.dot(u)/u.mag()).add(c),b=m.dist(a);m.dist(c)+m.dist(p)>=c.dist(p)+5||b<n&&(r=h+1,n=b)}i.splice(r,0,o)}main.staticKnots.push(o),this.update()}export(){const t=[];for(const[s,o]of this.obj.points)t.push([round(s),round(o)]);return`new ${x[this.obj.constructor]}(${JSON.stringify(t)})`}}class j extends y{constructor(t){super(t),this.knots=[new l(this.obj.x,this.obj.y,this),new l(this.obj.x+this.obj.w,this.obj.y+this.obj.h,this)],main.staticKnots.push(...this.knots),this.calcCenter()}update(t,s){super.update(t,s),this.obj.x=this.knots[0].pos.x,this.obj.y=this.knots[0].pos.y,this.obj.w=this.knots[1].pos.x-this.obj.x,this.obj.h=this.knots[1].pos.y-this.obj.y}export(){let t=`new ${x[this.obj.constructor]}(${round(this.obj.x)}, ${round(this.obj.y)}, ${round(this.obj.w)}, ${round(this.obj.h)}`;if(this.obj instanceof K){const s=p5.Vector.normalize(this.obj.force);t+=`, createVector(${round(s.x)}, ${round(s.y)})`}return`${t})`}}class F extends j{constructor(t){super(t),this.deltas=[new E(this.obj.x+this.obj.w,this.obj.y+this.obj.h/2,this,createVector(1,0)),new E(this.obj.x+this.obj.w/2,this.obj.y+this.obj.h,this,createVector(0,1))],main.staticKnots.push(...this.deltas)}update(t,s){if(super.update(t,s),this.deltas.includes(t)){const o=this.deltas[0].pos.x-this.obj.x-this.obj.w/2,i=this.deltas[1].pos.y-this.obj.y-this.obj.h/2;this.obj.dw=o,this.obj.dh=i}else{const o=createVector(this.obj.x+this.obj.w/2+this.obj.dw,this.obj.y+this.obj.h/2),i=createVector(this.obj.x+this.obj.w/2,this.obj.y+this.obj.h/2+this.obj.dh);this.deltas[0].pos=o,this.deltas[0].origin=o,this.deltas[1].pos=i,this.deltas[1].origin=i}}draw(){const t=this.obj;fill(0,0,255),rect(this.obj.x,this.obj.y,this.obj.w,this.obj.h),push(),noFill(),strokeWeight(1),stroke(255,0,0),rect(t.x+t.w/2-t.dw,t.y+t.h/2-t.dh,2*this.obj.dw,2*this.obj.dh),pop();for(const s of this.knots)s.draw();for(const s of this.deltas)s.draw();this.centerKnot.draw()}}class X{constructor(t){this.obj=t,this.startKnot=new l(t.start.x,t.start.y,this),this.endKnot=new l(t.end.x,t.end.y,this),main.staticKnots.push(this.startKnot,this.endKnot)}draw(){this.obj.draw(),this.startKnot.draw(),this.endKnot.draw()}update(){this.obj.start=this.startKnot.pos,this.obj.end=this.endKnot.pos}export(){return`new ${x[this.obj.constructor]}(${this.startKnot}, ${this.endKnot})`}}const z=[{name:"Square Wall",create:(e,t)=>new j(new P(e,t,30,30))},{name:"Ice",create:(e,t)=>new j(new $(e,t,30,30))},{name:"Bouncer",create:(e,t)=>new v(new I(e,t))},{name:"Slope",create:(e,t)=>new j(new K(e,t,30,30,createVector(1,0))),render:Y},{name:"Polygon Wall",create:()=>{const e=new y(new B([]));return main.selectedPolygon=e,e},render:g},{name:"Water",create:()=>{const e=new y(new S([]));return main.selectedPolygon=e,e},render:g},{name:"Sand",create:()=>{const e=new y(new C([]));return main.selectedPolygon=e,e},render:g},{name:"Teleporter",create:(e,t)=>new X(new L(e,t,e,t))},{name:"Moving Platform",create:(e,t)=>new F(new T(e,t,30,30,0,0))}],J=document.querySelector(".object-template"),A=document.querySelector(".objects-list");for(const e of z){const t=document.createElement("button");t.textContent=e.name,t.addEventListener("click",()=>{const s=e.create(main.camera.pos.x,main.camera.pos.y);main.staticObjs.push(s);const i=(e.render||V)(s,e.name);A.append(i)}),J.append(t)}window.p5=W;window.mousex=void 0;window.mousey=void 0;window.main=new N;window.setup=()=>{noStroke();const e=createCanvas(.8*windowWidth,windowHeight).parent(document.querySelector(".canvas-content"));e.mousePressed(Q),e.mouseClicked(Z),e.mouseWheel(_),e.elt.addEventListener("selectstart",t=>t.preventDefault()),e.elt.addEventListener("contextmenu",t=>t.preventDefault()),e.elt.addEventListener("wheel",t=>t.preventDefault()),e.elt.addEventListener("mousedown",t=>{t.button==1&&t.preventDefault()}),main.init()};window.draw=()=>{push(),main.draw(),pop(),main.selectedPolygon&&(fill(0),textAlign(CENTER),textSize(20),text(`Left click to add vertex, Right click to remove vertex
Esc to finish`,width/2,30))};function Q(){if(main instanceof f||(mouseButton==CENTER&&main.camera.beginMove(),!main.selectedPolygon))return;let e=main.selectedPolygon;if(mouseButton==LEFT)e.addPoint(mousePos.x,mousePos.y);else if(mouseButton==RIGHT){for(let t=e.knots.length-1;t>=0;t--)if(e.knots[t].check()){e.knots.splice(t,1),e.update();break}}}function Z(){if(main instanceof f){const e=W.Vector.sub(createVector(mousex,mousey),main.mainb.pos).div(32);main.mainb.vel=e}}window.keyPressed=()=>{main.selectedPolygon&&key=="Escape"&&(main.selectedPolygon=null)};window.mouseReleased=()=>{main instanceof f||(main.hasSelected=!1,main.camera.endMove())};function _(e){main.camera.changeScale(e.deltaY)}document.querySelector(".play-btn").addEventListener("click",()=>{main instanceof f?main.reset():main.playMode()});document.querySelector(".edit-bound-btn").addEventListener("click",()=>{main.selectedPolygon=main.levelBounds});document.querySelector(".export-btn").addEventListener("click",()=>{let e="";for(const s of main.staticObjs)e+=s.export()+`,
`;let t=`{
mainb: [${main.mainb.knot}],
hole: [${main.hole.knot}],
static: [${e}],
balls: [],
bounds: ${main.levelBounds.export()},
}`;document.querySelector(".export-text").value=t});document.querySelector(".copy-export-btn").addEventListener("click",async()=>{const e=document.querySelector(".export-text").value;await navigator.clipboard.writeText(e),document.querySelector(".copy-export-btn").textContent="Copied!",setTimeout(()=>{document.querySelector(".copy-export-btn").textContent="Copy"},1e3)});
